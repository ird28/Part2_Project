% Isaac Dunn Part II Computer Science Dissertation
\documentclass[12pt,a4paper,twoside,openright]{report}
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage[margin=25mm]{geometry}  % adjusts page layout
\usepackage{graphicx}  % allows inclusion of PDF, PNG and JPG images
\usepackage{verbatim}
\usepackage{docmute}   % only needed to allow inclusion of proposal.tex
\usepackage{amsmath}
\usepackage{amsfonts}

\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title page


\pagestyle{empty}

\rightline{\LARGE \textbf{Isaac Dunn}}

\vspace*{60mm}
\begin{center}
\Huge
\textbf{Dynamic Partial-Order Reduction for Model Checking} \\[5mm]
Computer Science Tripos -- Part II \\[5mm]
Clare College \\[5mm]
\today  % today's date
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Isaac Dunn                            			 \\
College:            & \bf Clare College                    				     \\
Project Title:      & \bf Dynamic Partial-Order Reduction for Model Checking \\
Examination:        & \bf Computer Science Tripos -- Part II, June 2016      \\
Word Count:         & \bf N    \\
Project Supervisors:& Dr. Jonathan Hayman \& Prof. Glynn Winskel             \\ 
\end{tabular}
}


\section*{Original Aim of the Project}

The original aim of the project was to build a system which
used dynamic partial-order reduction to improve the performance
of a model checking algorithm which could be used to find
assertion violations and deadlocks.

\section*{Work Completed}

The original aim of the project was met and exceeded, with
a stateful implementation of dynamic partial-order reduction
also being produced.

\section*{Special Difficulties}

No special difficulties were encountered, only the usual dozens of
difficult-to-find bugs.
 
\newpage
\section*{Declaration}

I, Isaac Dunn of Clare College, being a candidate for Part II of the Computer
Science Tripos, hereby declare
that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed:}

\bigskip
\leftline{Date:}

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}

Put acknowledgements here.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the body

\pagestyle{headings}

\chapter{Introduction}

\section{Model Checking}
We want to be very sure that some computer
programs are correct. Testing is not good
enough -- all software products have been
tested, but according to Dijkstra,
\emph{``Testing shows the presence,
	not the absence, of bugs''}.

Model checking is a category of formal
methods, in which \emph{(basic explanation of
model checking)}

\section{The State Explosion Problem}
Concurrent software programs in practice often
use threads as their model. The number of possible
interleavings of concurrent threads blows up very 
quickly.

Give some maths, some empirical results,
and a state space diagram showing this.

\section{Partial-Order Reduction}
Idea: some interleavings are equivalent. If you
can identifying which are equivalent, you only
have to explore a subset. \emph{Give picture.}

Partial-order reduction is a category of techniques
that aim to identify such equivalences and so
perform model checking more efficiently.

\section{Dynamic Partial-Order Reduction}
DPOR uses runtime information to identify
equivalent interleavings. In fact, it assumes
that all interleavings are equivalent, picks
one arbitrarily, and takes note of backtracking
points which might lead to un-equivalent
interleavings, which are then explored on
backtrack.

\section{This Project}
The aim of this project is to implement DPOR.

It succeeded, and went further, implementing
a stateful version of DPOR, in which a table
of visited states is kept, and when a state is
re-visited, it is not re-explored. However, care
must be taken to make sure that this approach is
sound.

\chapter{Preparation}

\section{Background Definitions}

\subsection{Processes and States}
We consider a system consisting of a finite set, $\mathcal{P}$,
of concurrent threads or processes (I use ``thread" and
``process" interchangeably throughout).
Each thread has its own local state, $s \in \mathcal{S}$, and there
is some shared global state, $g \in \mathcal{G}$. The overall
state of the system at any instant is therefore a member of the set
$ State = (\mathcal{P} \to \mathcal{S}) \times \mathcal{G} $.

Each process executes a sequence of operations, as
specified in some programming language, each of which can
operate on the thread's local state $s$ or the shared
state $g$. If an operation
operates on $g$, it is said to be \emph{visible}, else it is said to be
\emph{invisible}.

\subsection{Transitions}
A \emph{transition} moves the system from one state to another,
by performing a finite sequence of invisible operations of some
process $p$, followed by a visible operation of the same process.
If process $p$ has local state $s$, then the transition $t_{p,s}$
that $p$ can make is defined to be a partial function taking the current
global state $g$ and giving $(s', g')$, the next local state for $p$
and the next global state for the system. Let $\mathcal{T}$ denote the
set of all transitions, so that
	\[\mathcal{T} = \mathcal{G} \rightharpoonup
				(\mathcal{S} \times \mathcal{G}).\]

A transition $t_{p,s}$ is said to be \emph{enabled} in a state
$(l, g)$ if and only if $l(p) = s$ and $t_{p,s}(g)$ is defined.
If $t_{p,s}$ is enabled in $\sigma = (l, g)$ and 
$t_{p,s}(g) = (s', g')$, then we say that the
execution of $t_{p,s}$ from $\sigma$ results in the unique successor
state $\sigma' = (l', g')$, where

\[
	l'(q) = \left\{\begin{array}{lr}
				s' & \textmd{if } p = q, \\
				l(q) &\textmd{if } p \neq q.
			\end{array} \right.
\]
In this case we write $\sigma \xrightarrow{t_{p,s}} \sigma'$.
We write $\longrightarrow^*$ to denote the transition reflexive
closure of $\longrightarrow$.
A state $\sigma$ is called a \emph{deadlock} when there is no transition
$t$ such that $t$ is enabled in $\sigma$.

In any state $\sigma = (l, g)$, let
$next(\sigma, p) = t_{p,l(p)}$ denote the unique next transition
to be executed by process $p$. For any transition $t_{p,s}$, let
$proc(t_{p,s}) = p$ denote the unique process executing that transition.

\subsection{Systems}
The behaviour of an entire \emph{transition system} is
specified with the tuple $A = (State, \Delta, \sigma_0)$,
where $\Delta \in State \to \mathbb{P}(State)$
is the \emph{transition relation} defined by
\[
	\sigma' \in \Delta(\sigma) \iff
	\exists t \in \mathcal{T}. \ \sigma \xrightarrow{t} \sigma'.
\]

\section{Model Checking}

When model checking, we are trying to establish whether a
given transition system is \emph{error-free} and
\emph{deadlock-free}. We therefore need to introduce two
new concepts.

We extend each transition system with a \emph{error relation}
$err : \mathcal{S} \to \mathbb{B}$, and a \emph{value relation}
$val : \mathcal{S} \to \mathbb{B}$, which decide whether a given
local state is in error state or a value state (i.e. a result has
been computed and no further operations are possible) respectively.

We say that a transition system $A = (State, \Delta, \sigma_0)$ is
\emph{error-free} if
\[
	\forall (l, g) \in State. \ \sigma_0 \longrightarrow^* (l, g)
	\implies \forall p \in \mathcal{P}.\ \neg\,err(l(p)),
\]
and is \emph{deadlock-free} if
\[
	\forall (l, g) \in State. \;\sigma_0 \longrightarrow^* (l, g)
	\wedge \neg \exists t \in \mathcal{T}.\;
		\exists\sigma \in State.\;(l, g) \longrightarrow \sigma
	\implies \forall p \in \mathcal{P}.\;val(l(p)).
\]

\section{Dynamic Partial-Order Reduction}


\chapter{Implementation}

\section{Development of Project Language (PL)}
\subsection{Syntax and Semantics}
First design a simple but fairly practical sequential language.
$(e, s) \longrightarrow^t (e', s')$
Then using these as threads, add a global store, and read and CAS
operations on that store.
$(e, s, g) \longrightarrow^t (e', s', g)$
A program consists of multiple $(e, s)$ threads, and one global store,
$g$, and at any given time any of the threads can advance.

See appendix for language definition.

\subsection{Parser}
Use <tool> and <tool> to specify the conversion of source code
into abstract expressions. Example?

\subsection{Interpreter}
Auxiliary functions for things like substitution, deciding if
an expression is a value, modifying de Bruijn indices.

Stores simply implemented as (location, value) pairs.

Function for getting next local step of thread, given global store.

Function for getting the next transition of a thread; all the local
steps up to and including a visible operation.

\section{Simple Model Checker}

Depth first search of state space. Present algorithm used.
Explain how errors and deadlocks are found.

\section{Dynamic Partial-Order Reduction}

\subsection{Clock Vectors}
\subsection{Locks}
Problem: many algorithms use locks. While \texttt{while locked do skip done}
is good enough, it results in a cycle in the state space, which causes
non-termination of DPOR.

Solution: add locks. New problem: no distinction between
transition not existing and not being enabled. Without
locks, all existing transitions were enabled; no longer
the case.

Solution: pass around Boolean stating whether or not the transition
is enabled.

\section{Stateful Model Checking}

\subsection{Simple Model Checker}
When searching through state space, the same state is often
re-encountered. Idea: keep track of visited states, and don't bother
re-exploring from those we have already explored.

\subsection{Dynamic Partial-Order Reduction}

\subsubsection{Na\"{\i}ve Approach}
The na\"{\i}ve approach is unsound.
Give explanation.

\subsubsection{Stateful Dynamic Partial-Order Reduction}
Idea: conservatively add in necessary points to backtrack sets.
Use visible operation dependency graph.

\chapter{Evaluation}

\section{Soundness of Model Checking}

\begin{itemize}
	\item Evidence of correctness of language implementation
	\item Example programs \& comparison to simple checker
\end{itemize}

\section{Efficiency of Model Checking}

\begin{itemize}
	\item Example programs
	\item Performance tables/graphs
\end{itemize}

\chapter{Conclusions}

This chapter is empty!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{First appendix}
 
 This appendix is empty!
 
\chapter{Second appendix}

This appendix is empty!

\chapter{Project Proposal}

\input{proposal_without_title}

\end{document}
